<!DOCTYPE html>
<html lang='ru'>
<head>
<meta charset='utf-8'>
<meta content='at8eqeq3' name='author'>
<meta content='Первая часть бесконечной истории о визуализации данных с ADS-B приёмника.' name='description'>
<meta content='Nanoc 4.12.1' name='generator'>
<meta content='width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0' name='viewport'>
<title>txt.at8eqeq3.me &mdash; О самолётах и данных, часть 1</title>
<link href='/img/userpic.svg' rel='icon' type='image/svg+xml'>
<link href='https://fonts.gstatic.com' rel='preconnect'>
<link href='/stylesheet.css' rel='stylesheet'>
<link href='https://fonts.googleapis.com/css2?family=Fira+Mono:wght@400;500;700&amp;display=swap' rel='stylesheet'>
<link href='https://fonts.googleapis.com/css2?family=Fira+Sans:ital,wght@0,200;0,300;0,700;1,200;1,300;1,700&amp;display=swap' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css' rel='stylesheet'>
</head>
<body>
<div id='content'>
<div id='header'>
<img alt='at8eqeq3&#39;s userpic' src='/img/userpic.svg'>
<h1>
<a href='/'>txt.at8eqeq3.me</a>
</h1>
<p>//&nbsp;текстятина</p>
</div>
<div id='main'>
<div id='tldr'>Я делал карту из табличных данных, и мне не очень понравилось.</div>
<div id='epigraph'>В этой части я рассказываю о задаче и первых попытках её решить.</div>
<h2 id="section">Введение</h2>

<p>Однажды случилось так, что я влюбился в гражданскую авиацию. То есть, до какого-то момента в жизни авиация существовала без меня: самолёты летали по небу, я ходил пешком, и мы нигде не пересекались. Ну, было два раза: летал в отпуск и обратно. Путь туда не помню вовсе (не напивался, как часто бывает, а просто был трое суток не спавши, а там реальность уже не очень-то воспринимается), путь обратно честно проспал, потому что спёкся в автобусе, пока ехал в аэропорт. А потом я сменил работу, и как-то так оказалось, что мы достаточно активно общаемся со строившимся ещё на тот момент новым центром АУВД, что во Внуково, да и с их коллегами в других регионах тоже иногда. И что-то нахлобучило: а какие у нас самолётики летают, а как и куда они летят, а что там за <a href="https://www.flightradar24.com">FlightRadar24</a>, а как там вообще это всё организовано, и тому подобные вопросы. А в какой-то момент ещё и пришлось сменить место жительства, и теперь у меня прямо над головой, только что не цепляя за крышу, иногда пролетают борта, следующие в&nbsp;Шереметьево.</p>

<p>Всё это привело к тому, что мне захотелось водить самолёт. Объективно, мне это не светит — по зрению меня не берут даже в машинисты электрички. Но есть симуляторы, что печально, но лучше, чем ничего вообще. У меня, как пользователя Линукса, было аж целых два варианта: <a href="http://home.flightgear.org/">FlightGear</a> бесплатно и <a href="https://www.x-plane.com/">X-Plane</a> (на тот момент 10 версии) в Steam за лютые бабки. При всей моей прижимистости, каким-то непостижимым образом склонился ко второму варианту. Более того, с релизом 11 версии, купил и её. Совсем сдурел. Но она мне пригодилась и для другой вещи, о которой статья. Хочу отметить, что формат данных в 11 версии отличается от такового в предыдущих, но не сильно, так что всё описанное с минимальными модификациями подойдёт для&nbsp;всего.</p>

<p>Помимо вождения самолёта, мне хотелось следить за тем, что летает буквально над моей головой. Есть, конечно, fr24, но вы же меня понимаете, иначе зачем вы читаете эту писанину. Надо чтобы своё. Дендрофекально, кишочками наружу, но своё. Всё уже давно придумано, и для этой цели существует <a href="https://www.rtl-sdr.com/"><span class="caps">RTL</span>-<span class="caps">SDR</span></a>, позволяющий относительно просто использовать приёмник спутникового ТВ с алиэкспресса за 500 рублей для почти чего угодно. Но есть нюансы — в с виду одинаковых приёмниках могут стоять разные тюнеры, у которых различаются доступные частоты. Короче, первый заказанный приёмник не вывозил нужные 1090 МГц, и я просто скакал по частотам и искал что-нибудь интересное. Так я нашёл <span class="caps">ACARS</span>, о котором как-нибудь отдельно расскажу, потому что штука тоже интересная. Между тем, подъехал следующий приёмник, теперь уже правильный, была сооружена коллинеарная антенна, установлен софт — сначала на <span class="caps">NAS</span>, а потом на RPi, потому что декодирование потока, как выяснилось, весьма прожорливо и мешает смотреть кинцо. В центре всего софтверного бардака работает <a href="https://github.com/flightaware/dump1090">dump1090</a>, обвешанный вокруг фидерами от fr24, <a href="https://flightaware.com/">fa</a> и <a href="https://www.radarbox24.com/">rb24</a>. Собственно, dump1090 (точнее, его веб-морда) и будет, с позволения сказать, дорабатываться. Не он сам, но карта для&nbsp;него.</p>

<p>В какой-то момент я решил, что dump1090 не хватает аэронавигационной схемоты. Там можно что-то включить, но оно показывает только Штаты, а до туда у меня чё-т антеннка не добивает (однажды я вытащу её на крышу, обзор там великолепный, но до Штатов всё равно не достать). Хотелось бы поближе. Схемота есть у fr24 и rb24, но там только транзитные маршруты, а у меня тут три аэропорта вокруг, и схемы входа и выхода мне гора-аздо интереснее. Придётся городить самому, ну да не в первый раз, чё уж. Итак, имеем карту, сделанную на OpenLayers, с основным слоем из <span class="caps">OSM</span>, что, в принципе, сейчас не очень важно. OpenLayers умеет кучу разных форматов картографических данных, поэтому у нас есть&nbsp;выбор.</p>

<p>Вторая задача — это источник данных. X-Plane выше я упомянул не просто так, данные я уволок именно оттуда. Они там немного тухлые, но никто, я подозреваю, от этого не помрёт. Можно, конечно, и свежими разжиться, но это стоит денег, что неприемлемо. Laminar Research, вероятно, не хотели бы, чтобы я их данными с кем-то делился, ну дык я этого и не буду делать. Моя копия показывается только мне, а уважаемой публике предлагается разжиться собственной&nbsp;копией.</p>

<p>Важно также отметить, что я работал с данными, используя язык ruby, поскольку он мне нравится. Полный код, если доживёт до конца написания статейки, обретётся где-то на Гитхабе. Надеюсь, моих комментариев к нему, а также достаточно высокой читабельности кода на ruby вообще, будет достаточно, чтобы читатель при желании мог воспроизвести те же действия на более близком ему&nbsp;языке.</p>

<h2 id="section-1">Исходные&nbsp;данные</h2>

<p>Вокруг этих самых данных основной сыр-бор. Попытаюсь рассказать, как на их основе можно получить что-то визуально приемлемое. Подозреваю, что это не единственно верный, а возможно и не верный вовсе способ, но вот он есть. Итак, немного изучив вопрос, имеем в каталоге с симулятором набор файлов, которые нам&nbsp;интересны:</p>

<ul>
  <li><code>earth_nav.dat</code> — радионавигационные средства (натурально радиостанции где-то стоят и что-то вещают, а самолёты на них&nbsp;ориентируются)</li>
  <li><code>earth_fix.dat</code> — точки пути (виртуальные точки в пространстве с заранее определёнными координатами, которые формируют разного рода маршруты. Могут иногда совпадать с реальными объектами из предыдущего пункта, наземными ориентирами, но чаще вообще ни с&nbsp;чем.</li>
  <li><code>earth_awy.dat</code> — воздушные трассы, соединяющие сущности из предыдущих двух пунктов. Да, самолёты не летают абы как, у них тоже есть шоссе (кроме пары стран в Европе, где от таких шоссе принципиально отказались, но как там у них в связи с этим УВД работает, я пока не в&nbsp;курсе).</li>
  <li><code>cifp/*.dat</code> — схемы входа и выхода для аэропортов, наиболее ценная для меня&nbsp;информация.</li>
</ul>

<p>Для всех этих наборов есть <a href="https://developer.x-plane.com/docs/data-development-documentation/">документация</a>, но я всё равно кратко расскажу о наиболее важных моментах. Забавный факт: слово earth в названии файлов обозначает нашу родную планету, потому как теоретически симулятор может изобразить и другие, лишь бы кто-то там радиостанций&nbsp;понавтыкал.</p>

<p>Итак, все файлы суть текстовые, таблицы с разделителями. У первых трёх разделитель — пробел, у остальных — запятая. <em>“Е” — Единообразие</em>. Пройдёмся по&nbsp;порядку.</p>

<h3 id="earthnavdat"><code>earth_nav.dat</code></h3>

<p>Достаточно противный файл. В первую очередь, потому что описывает в одной куче достаточно разные объекты, имеющие разное количество полей, да и смысл этих полей не всегда одинаковый (но в 11 версии его заметно причесали, и теперь хотя бы самые важные поля вроде ИД и координат всегда на одних и тех же местах). Тут я использовал <code>String#split</code>, передавая ему вторым параметром количество полей в записи в зависимости от первых двух символов. Больше всего меня интересовали поля 1 и 2 (нумерация с 0), содержащие координаты, а также поле 7 — идентификатор объекта. К сожалению, для однозначной идентификации объекта нужно ещё поле 9 (код региона из документа <span class="caps">ICAO</span> 7910) и поле 8 (ИД региона — либо код аэропорта, либо строка “<span class="caps">ENRT</span>”). ИД объекта вроде как должен быть уникален в пределах регионального кода, но в аэропортах это часто не так: назвать маяки с двух торцов полосы A и B — это как здрасте. Поэтому при разборе приходится идти на разнообразные хитрости, собирая идентификатор объекта из трёх полей (что нам ещё&nbsp;аукнется).</p>

<p>Поскольку городить карту на всю планету мне не хочется, я отбираю только записи с кодом региона <span class="caps">UU</span> (он как раз вокруг меня примерно поровну во все стороны, и ещё на север&nbsp;хвостик).</p>

<h3 id="earthfixdat"><code>earth_fix.dat</code></h3>

<p>Тут попроще. 0 и 1 поле — это координаты, 2 — ИД, 3 — ИД региона, 4 — код региона, всё как у предыдущего. Можно, опять же, отфильтровать по ИД региона. На самом деле, это не совсем правильно, но никто, опять же, от этого не помрёт. Нам картинки смотреть, а не самолёты&nbsp;водить.</p>

<p>Разобранные данные из этих двух файлов понадобятся нам для двух вещей: первое — точечные объекты на карте; второе — сборка отрезков по ещё не разобранным файлам. В связи с первым пунктом я решил на ходу формировать подходящую структуру для вывода <span class="caps">GIS</span>-данных, формат которых в ходе долгих мучений был принят как geo<span class="caps">JSON</span>, просто потому что <code>IO.puts(something.toJSON)</code> и думать не надо. Хочется обратить внимание, что в geo<span class="caps">JSON</span> (да и во многих других форматах) координаты представлены в виде <code>[lon, lat]</code>, тогда как в исходном файле (и у меня в голове) широта указана прежде долготы, что я, конечно, сначала упустил и получил довольно странный результат. Ещё один противный факт про geo<span class="caps">JSON</span>: без properties у feature файлик невалидный, надо их всегда указывать, пусть даже там будет пустой ассоциативный массив. Ну, в какой-то момент я пришёл к выводу, что пропертя будут не пустые. Для точек я указываю, что они такое есть — fix, радиомаяки или ещё&nbsp;что.</p>

<h3 id="earthawydat"><code>earth_awy.dat</code></h3>

<p>Относительно просто. Два набора полей (с 0 по 5), позволяющих, <em>помолясь</em>, идентифицировать точки в пространстве (ИД, код региона и тип), обозначающие начало и конец отрезка, и 10 поле с его названием. Тут мы тоже сразу формируем структуру для вывода отрезков, не забывая указывать в properties тип,&nbsp;пригодится.</p>

<h3 id="cifpdat"><code>cifp/*.dat</code></h3>

<p>Самые противные, но и самые интересные файлы. Противные, в большей мере, потому что формат в документации состоит из ссылок на различные участки документа <span class="caps">ARINC</span> <span class="caps">SPECIFICATION</span> 424. Это огромная портянка (её ещё поди-ка нагугли), описывающая некий формат данных, которые с нашими соотносятся только содержанием. Для общего развития можно ознакомиться полностью, но нас интересует довольно&nbsp;мало.</p>

<p>Вообще в этих файлах есть два принципиально различных типа записей — <span class="caps">RWY</span> и всё остальное. <span class="caps">RWY</span> — это параметры ВПП, а остальное — процедуры. Формат их различается совсем. Сначала надо разобрать ВПП и добавить их ко всем имеющимся точечным объектам и, разумеется, пометить принадлежностью к аэропорту, иначе перепутаются. Неожиданно для всех, координаты точек в этих записях представлены не в виде градусов с десятичной дробью, а как градусы, минуты и секунды с двумя знаками после запятой, и всё это без каких-либо разделителей. Узнал я об этом, только собрав карту. Кот бы мог&nbsp;подумать.</p>

<p>Дальше можно разбирать процедуры. Нам нужно очень мало из предоставленных данных (они и так жиденькие). Процедуры представлены в виде списка секций, имеющих возрастающую нумерацию. Сначала мы разбираем, где какая процедура (<span class="caps">SID</span>, <span class="caps">STAR</span> или <span class="caps">APPCH</span>), выбираем её ИД и ИД маршрута, находим в списке точечных объектов, куда попадает очередная секция (тут нам помогают коды региона и знание, к какому вообще аэропорту относится процедурка) и лепим их в список отрезков. Некоторые секции волшебные — предполагают следование по как-то хитро вычисленной дуге (тут мне было лень думать, и дуга вдруг стала прямой) или <em>векторение</em> диспетчером (в его отсутствие тоже как-то прямовато получилось), и когда-нибудь мы это примем, но не&nbsp;сейчас.</p>

<p>Выше я говорил о проблеме с идентификацией точек, вот тут она и всплывает. В файле есть код региона. ИД региона <em>по идее</em> должно подставляться из имени файла (оно совпадает с <span class="caps">ICAO</span>-кодом аэропорта, к которому относятся процедурки), но есть нюанс. Некоторые точки вполне себе <span class="caps">ENRT</span>, поэтому всегда надо проверять. Сначала ищем точку от аэропорта, потом <span class="caps">ENRT</span>, а если не нашли — удивляемся и орём “Achtung!”. Ещё временами попадаются точки из соседних регионов. Это нормально, но у нас их нет. Придётся просто забить на&nbsp;это.</p>

<p>Ну, короче. Если всё изначально собиралось как надо, в конце мы имеем большой и толстый geo<span class="caps">JSON</span> с точками и линиями. Всем хорош, но некрасив, а с учётом размера — неприлично тормозит в браузере. Надо делать&nbsp;картинками.</p>

<h2 id="qgis"><span class="caps">QGIS</span></h2>

<p>Интересная такая софтинка для работы с <span class="caps">GIS</span>-данными всех сортов и расцветок. В частности, понимает и geo<span class="caps">JSON</span> как векторные слои. Что интересно, принципиально не хочет смешивать при импорте точки и линии, поэтому пришлось подгружать один файл дважды. Зато видит properties и позволяет по ним делать различное оформление для элементов — цвет, символы и всё&nbsp;такое.</p>

<p>Собственно, тут мы накидываем слой <span class="caps">OSM</span>, чтобы видеть, где мы находимся, и два слоя с нашим geo<span class="caps">JSON</span> — для точек и для линий. Настраиваем для них представления, фильтруя по свойству, которое мы добавили при разборе исходников. Для линий я также добавил различные, в зависимости от типа, смещения, чтобы они не сливались: погоды не делает, а наглядность повышается. Штатный функционал <span class="caps">QGIS</span> позволяет сгладить углы у линий. Это тоже делает карту более читаемой: сразу видно, где поворот, а где перекрёсток. Функция создаёт новый слой, так что копируем свойства представления с исходного слоя и отключаем&nbsp;его.</p>

<figure>
  <img src="/img/adsb-01-01.png" alt="Пример генерируемой карты" />
  <figcaption>Пример генерируемой карты</figcaption>
</figure>

<p>Схема, да ещё и наложенная на карту — штука красивая, но пока совершенно непрактичная. Самолёты по ней не летают, и я не уверен, что можно убедить <span class="caps">QGIS</span> показывать их в реальном времени. Ну, да не очень-то и хотелось, на самом деле. Нам нужно нарезать тайлы для OpenLayers. Штатно <span class="caps">QGIS</span> этого не может, но есть <a href="http://plugins.qgis.org/plugins/qtiles3/">плагин для этого</a>. Немного экспериментов с настройками, и вот мы уже активно раскладываем по каталогам квадратные картинки. Из минусов — работает непристойно медленно. Устал ждать, пока нарежет тайлы для zoom level 8 и 9, на большее терпения уже не&nbsp;хватило.</p>

<p>Плагин раскладывает картинки сразу в структуру, совместимую с OpenLayers, поэтому надо их просто положить на любой http-сервер (например, на тот же lighttpd, которым предполагается по умолчанию отдавать морду dump1090) и натравить карту на соответствующий <span class="caps">URL.</span>&nbsp;Готово!</p>

<h2 id="section-2">Заключение</h2>

<p>Цель, конечно, достигнута. Расстраивают следующие&nbsp;моменты:</p>

<ul>
  <li>отсутствие некоторых точек, потому что они в другом регионе. В принципе, разбор происходит достаточно быстро, так что можно разобрать всё целиком, но, допустим, <code>cifp/*.dat</code> брать только нужные и отрисовывать только нужный участок&nbsp;карты;</li>
  <li>возможно, стоит генерировать отдельные слои для enroute и аэропортов, чтобы было меньше каши. Да и процедуры неплохо бы&nbsp;разделить;</li>
  <li>недостаточно автоматизации процесса. А это как раз тема для второй&nbsp;части.</li>
</ul>

<div id='meta'>
<div id='date'>
<i class='far fa-calendar-alt'></i>&nbsp;2019-05-05
</div>
<div id='tags'>
<i class='fas fa-tags'></i>
<div class='tag'>авиация</div>
<div class='tag'>визуализация данных</div>
<div class='tag'>gis</div>
</div>
<div id='links'>
<i class='fas fa-link'></i>
<div class='link'>
<a href='/adsb-02.html'>О самолётах и данных, часть&nbsp;2</a>
</div>
<div class='link'>
<a href='/adsb-03.html'>О самолётах и данных, часть&nbsp;3</a>
</div>
</div>
</div>
</div>
<div id='footer'>
<i class='fas fa-link'></i>
<a href='/'>txt.at8eqeq3.me</a>
<i class='fab fa-github'></i>
<a href='https://github.com/at8eqeq3/txt.at8eqeq3.me'>исходники</a>
<i class='fab fa-creative-commons-by'></i>
<a href='https://creativecommons.org/licenses/by/4.0/'><span class="caps">CC</span>-<span class="caps">BY</span></a>
</div>
</div>
</body>
</html>
